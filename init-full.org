#+TITLE: Brian Stiles' Emacs configuration
#+OPTIONS: toc:4 h:4

* Configuration
#+begin_src emacs-lisp :results silent
   (unless noninteractive (message "Loading %s..." load-file-name))
#+end_src

** init.el and the general initialization flow
=init.el= is the start of the configuration. It contains a few global
definitions used commonly, such as the location of my config files and
some helpers to set key bindings. It also loads machine-specific
configuration and overrides Custom's configuration file location.

If the Emacs instance is older than 24.4, only =init-minimal.el= is
loaded. Otherwise, full configuration continues.

*** Minimal configuration
=init-minimal.el= just creates a few thin wrappers for often-used
functions or commands and assigns a number of global key bindings. The
intent is to capture the most used settings, key bindings, etc. to
make basic editing comfortable and that require no additional software
to be installed

*** Full configuration
Full configuration starts in =init.el= by loading =package=,
=use-package=, =org=, and =org-dotemacs= just prior to handing control
to this file, =init-full.org=.

*** Package management
Packages are generally loaded from the ELPA package management
infrastructure, but via =use-package= so that the manifest is encoded
in the configuration source files, rather than manual usage of the
package manager. This should make it easier to set up new machines.

*** Setting up a new machine
All configuration files are stored in =MY-EMACS-CONFIG-DIR=. This
directory is managed as a Git repository. The directory can be cloned
to a new machine in =MY-EMACS-CONFIG-DIR= (usually under
=~/.emacs.d=).  There is a shell script named =setup.sh= in the config
dir that can be used to link =init.el= into =~/.emacs.d= and to
configure the machine identifier used to select machine-specific
configuration.

All package management is done via config files via =use-package=, so
dependencies should be automatically installed on first run.

*** Machine-specific configuration
Machine-specific configuration is stored in files in
=MY-EMACS-CONFIG-DIR= named =local-config-<MACHINE>.el=. The
appropriate file is determined by =machine-identifier.el= created by
=setup.sh= in =~/.emacs.d=.

*** Content

**** init.el
#+INCLUDE: "init.el" src emacs-lisp

**** init-minimal.el
#+INCLUDE: "init-minimal.el" src emacs-lisp

** Personal information
#+begin_src emacs-lisp :results silent
  (setq user-full-name "Brian Stiles"
        user-mail-address "bstiles@bstiles.net")
#+end_src

** Key bindings
Key bindings should be set with =my-global-set-key= or =my-define-key=
(defined in =init.el=) which are thin wrappers around =global-set-key=
and =define-key= that track the bindings for easy description with
=my-describe-key-bindings=. All key bindings that I have set can be
viewed with =my-describe-key-bindings=.

*** Machine-specific file key bindings (machine)
Use the macro =my-make-find-file-fn= defined in =init.el= to create
key bindings for often used files. These are typically appropriate for
use in machine-specific configurations since they are file path
dependent. Define bindings like so:

#+begin_example :results silent
  (my-make-find-file-fn my-file-org-work "/path/to/file)
#+end_example

See =local-config-Brians-MacBook-Pro.el= for examples.

*** Global keybindigs (full)

**** File access bindings
#+begin_src emacs-lisp :results silent
  (my-make-find-file-fn my-file-init-full-org (expand-file-name "init-full.org" my-emacs-config-dir))
  (my-global-set-key "C-c g e" 'my-file-init-full-org)
  (my-global-set-key "C-c g E f" 'my-file-init-full-org)

  (my-make-find-file-fn my-file-emacs-config-dir my-emacs-config-dir)
  (my-global-set-key "C-c g E e" 'my-file-emacs-config-dir)
#+end_src

**** Uncategorized
#+begin_src emacs-lisp :results silent
  ; XXX
  (my-global-set-key "C-." 'company-complete-common)
  (my-global-set-key "<f5>" 'company-complete-common) ; For terminals (mapped to C-. in iTerm2)
  ;; XXX Tie to mode/terminal type
  (my-global-set-key "C-c A" 'my-align-let-like-forms)
  (my-global-set-key "C-c c" 'column-highlight-mode)
  (my-global-set-key "C-c C" 'my-set-colors)
  (my-global-set-key "C-c g G" 'my-rgrep-in-project)
  (my-global-set-key "C-c g s" 'my-buffer-shell)
  (my-global-set-key "C-c h b" 'helm-buffers-list)
  (my-global-set-key "C-c h i" 'helm-imenu)
  (my-global-set-key "C-c h p" 'helm-pages)
  (my-global-set-key "C-c h P" 'helm-projectile)
  ;(my-global-set-key "C-c h g" 'my-helm-ls-git-ls)
  (my-global-set-key "C-c n c" 'cider-connect)
  (my-global-set-key "C-c n j" 'cider-jack-in)
  (my-global-set-key "C-c n n" 'cider-connection-browser)
  (my-global-set-key "C-c n q" 'cider-quit)
  (my-global-set-key "C-c n r" 'cider-switch-to-repl-buffer)
  (my-global-set-key "C-c n s" 'cider-scratch)
  (my-global-set-key "C-c n u" 'my-cider-user-ns)
  (my-global-set-key "C-c n U" 'my-user-clj)
  (my-global-set-key "C-c o A" 'org-align-all-tags)
  (my-global-set-key "C-c o a" 'org-agenda)
  (my-global-set-key "C-c o b h" 'my-hide-blocks-in-subtree)
  (my-global-set-key "C-c o b H" 'org-hide-block-all)
  (my-global-set-key "C-c o b s" 'my-show-blocks-in-subtree)
  (my-global-set-key "C-c o b S" 'org-show-block-all)
  (my-global-set-key "C-c o h h" 'helm-org-in-buffer-headings)
  (my-global-set-key "C-c o h n" 'my-helm-org-named-blocks)
  (my-global-set-key "C-c o F" 'my-set-org-agenda-files)
  (my-global-set-key "C-c o l" 'orgstruct-mode)
  (my-global-set-key "C-c o r" 'org-capture)
  (my-global-set-key "C-c o t" 'orgtbl-mode)
  (my-global-set-key "C-c o T" 'my-org-table-to-gfm-table)
  (my-global-set-key "C-c s !" 'run-skewer)
  (my-global-set-key "C-c s r" 'skewer-repl)
  (my-global-set-key "C-c s R" 'my-skewer-reload)
  (my-global-set-key "C-c s s" 'my-skewer-soft-reload-HACK)
  (my-global-set-key "C-c T" 'my-cider-test-function)
  (my-global-set-key "C-c C-t" 'my-show-time)
  (my-global-set-key "C-x C-b" 'helm-buffers-list)
  (my-global-set-key "C-x B" 'ibuffer)
  (my-global-set-key "C-M-S-h" 'auto-highlight-symbol-mode)
  (my-global-set-key "C-M-S-q" 'my-indent-top-level-sexp)
  (my-global-set-key "C-M-z" 'my-toggle-window-width)
  (my-global-set-key "C-M-S-z" 'my-toggle-window-height)
  (my-global-set-key "M-`" 'other-frame)
  (my-global-set-key "M-~" 'my-other-frame-reverse)
#+end_src

*** Company keybindings
#+begin_src emacs-lisp :results silent
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous))
#+end_src

** Environment variables on OS X
Emacs for OS X doesn't pick up the PATH defined in .bashrc/.profile.

#+begin_src emacs-lisp :results silent
  (use-package exec-path-from-shell
    :ensure t
    :pin melpa)

  (if (eq system-type 'darwin)
      (exec-path-from-shell-initialize))

  (setq explicit-shell-file-name (getenv "SHELL"))
  (setq shell-file-name (getenv "SHELL"))

#+end_src

** Projectile
#+begin_src emacs-lisp :results silent
  (use-package projectile
    :ensure t
    :pin melpa)
#+end_src

** Find File In Project
#+begin_src emacs-lisp :results silent
  (use-package find-file-in-project
    :ensure t
    :pin melpa)
#+end_src

** Org customizations

*** Set agenda files for current project
#+begin_src emacs-lisp :results silent
  (require 'find-lisp)
  (require 'projectile)
  (defun my-set-org-agenda-files ()
    (interactive)
    
    (let ((files
           (let ((filep 'find-lisp-default-file-predicate)
                 (dirp (lambda (dir parent)
                         (and (find-lisp-default-directory-predicate dir parent)
                              (not (string= "Historical" dir)))))
                 (find-lisp-regexp "\.org$"))
             (find-lisp-find-files-internal
              (projectile-project-root)
              filep
              dirp))))
      (setq org-agenda-files
            (if (member (expand-file-name "~/org/one-ring.org") files)
                files
              (cons "~/org/one-ring.org" files)))
      (message "%s agenda file%s."
               (length files)
               (if (= 1 (length files))
                   "" "s"))))
#+end_src

*** Turn on Auto Fill mode
#+begin_src emacs-lisp :results silent
  (add-hook 'org-mode-hook (lambda () (auto-fill-mode 1)))
#+end_src

*** Turn on helm support
#+begin_src emacs-lisp :results silent
  (use-package helm-projectile
    :ensure t
    :pin melpa)
  (require 'helm-org)
#+end_src

*** Re-bind helm-imenu to helm-org-in-buffer-headings
#+begin_src emacs-lisp :results silent
  (define-key org-mode-map (kbd "C-c h i") 'helm-org-in-buffer-headings)
#+end_src

** File system
#+begin_src emacs-lisp :results silent
  (require 'dired-x)
#+end_src

** HTML
#+begin_src emacs-lisp :results silent
  ;; - Handles syntax highlighted for org-html-export.  Exports buffers to
  ;; - syntax highlighted html.
  (use-package htmlize
    :ensure t
    :pin marmalade)

  (defun my-html-template ()
    "Adds boilerplate to the current buffer suitable for an HTML file."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((template-buffer (find-file-noselect "~/bin/00_HTML_TEMPLATE.html"))
            start
            end)
        (save-excursion
          (set-buffer template-buffer)
          (setq start (point-min) end (point-max)))
        (insert-buffer-substring template-buffer start end)
        (kill-buffer template-buffer))))
#+end_src

** Skewer
#+begin_src emacs-lisp :results silent
  (use-package skewer-mode
    :ensure t
    :pin melpa)

  (defun my-skewer-reload ()
    (interactive)
    (let ((buf (get-buffer "*skewer-repl*")))
      (if buf
          (with-current-buffer buf
            (goto-char (point-max))
            (insert "window.location.reload()")
            (comint-send-input)))))

  (defun my-skewer-soft-reload-HACK ()
    (interactive)
    (let ((buf (get-buffer "*skewer-repl*")))
      (if buf
          (with-current-buffer buf
            (goto-char (point-max))
            (insert "window.location.search=''+new Date().getTime()")
            (comint-send-input)))))
#+end_src

** Go Programming
#+begin_src emacs-lisp :results silent
  (use-package go-mode
    :ensure t
    :pin melpa)
#+end_src

** OCaml Programming
#+begin_src emacs-lisp :results silent
  (use-package tuareg
    :ensure t
    :pin melpa)
#+end_src

** Reason Programming
#+begin_src emacs-lisp :results silent
  ;; 2016-10-28 bstiles: Re-enable after figuring out how to
  ;; automatically install the dependencies

  ; (setq opam (substring (shell-command-to-string "opam config var prefix") 0 -1))
  ; (add-to-list 'load-path (concat opam "/share/emacs/site-lisp"))
  ; (setq refmt-command (concat opam "/bin/refmt"))

  ; (require 'reason-mode)
  ; (require 'merlin)
  ; (setq merlin-ac-setup t)
  ; (add-hook 'reason-mode-hook (lambda ()
  ;                               (add-hook 'before-save-hook 'refmt-before-save)
  ;                               (merlin-mode)))
#+end_src

** JavaScript Programming

*** js2-mode
#+begin_src emacs-lisp :results silent
  (use-package js2-mode
    :ensure t
    :pin melpa)
#+end_src

*** tern
#+begin_src emacs-lisp :results silent
  (use-package tern
    :ensure t
    :pin melpa)
  (use-package company-tern
    :ensure t
    :pin melpa)
#+end_src

*** json-mode
#+begin_src emacs-lisp :results silent
  (use-package json-mode
    :ensure t
    :pin melpa)
#+end_src

** Coffee Programming
#+begin_src emacs-lisp :results silent
  (use-package coffee-mode
    :ensure t
    :pin melpa)
#+end_src

** Markdown
#+begin_src emacs-lisp :results silent
  (use-package markdown-mode
    :ensure t
    :pin melpa)
#+end_src

** Chores/Emacs hygiene

*** Midnight mode
For cleaning up buffers not recently used. Provides
=clean-buffer-list= which kills old buffers that have not been
displayed recently.
#+begin_src emacs-lisp :results silent
  (require 'midnight)
#+end_src

** XML/HTML commands

*** Escape text
#+begin_src emacs-lisp :results silent
  (defun my-escape-xml ()
    (interactive)
    (let ((escaped (xml-escape-string (buffer-substring (mark) (point)))))
      (insert escaped)
      (delete-active-region)))
#+end_src

** YAML
#+begin_src emacs-lisp :results silent
  (use-package yaml-mode
    :ensure t
    :pin melpa)
#+end_src

** Dockerfiles
#+begin_src emacs-lisp :results silent
  (use-package dockerfile-mode
    :ensure t
    :pin melpa)
#+end_src

** BATS
#+begin_src emacs-lisp :results silent
  (use-package bats-mode
    :ensure t
    :pin melpa)
#+end_src

** PlantUML
#+begin_src emacs-lisp :results silent
  ;; 2015-05-28 bstiles: plantuml-mode blows up if this isn't set
  (setq plantuml-jar-path (expand-file-name "~/.emacs.d/lisp/org-extensions/plantuml.jar"))
  (use-package plantuml-mode
   :ensure t
   :pin melpa)
#+end_src

Tell the Org Babel tooling where the JAR file is.
#+begin_src emacs-lisp :results silent
  (setq org-plantuml-jar-path plantuml-jar-path)
#+end_src

** Paredit
#+begin_src emacs-lisp :results silent
  (use-package paredit
    :ensure t
    :pin melpa)
#+end_src

** CIDER
#+begin_src emacs-lisp :results silent
  (use-package cider
   :ensure t
   :pin melpa-stable)
#+end_src

*** Test helpers
#+begin_src emacs-lisp :results silent
  (defun my-cider-user-ns ()
    (interactive)
    (cider-repl-set-ns "user"))
  (defun my-user-clj ()
    (interactive)
    (let ((file "dev/user.clj"))
      (find-file (expand-file-name file (projectile-project-root)))
      (run-hooks 'projectile-find-file-hook)))
  (defun my-cider-test-function (arg)
    (interactive "P")
    (lexical-let*
        ((buf (current-buffer))
         (run-test (lambda ()
                     (with-current-buffer buf
                       (let* ((start nil)
                              (fn (save-excursion
                                    (goto-char (cider-defun-at-point-start-pos))
                                    (forward-word)
                                    (skip-syntax-forward " ")
                                    (setq start (point))
                                    (forward-sexp)
                                    (buffer-substring-no-properties start (point)))))
                         (cider-interactive-eval (concat "(test #'" fn ")")))))))
      (if (null arg)
          (cider-interactive-eval
           (cider-defun-at-point)
           (lambda (result)
             (nrepl-dbind-response result (err)
               (if err
                   (message (s-trim err))
                 (funcall run-test))))
           (cider--region-for-defun-at-point))
        (funcall run-test))))
#+end_src

*** Bug fix                                                                      :bug:
`cider-clojure-interaction-mode` remaps Enter to evaluate.
#+begin_src emacs-lisp :results silent
  (add-hook 'cider-clojure-interaction-mode-hook
            (lambda ()
              (define-key cider-clojure-interaction-mode-map
                [remap paredit-newline] nil)))
#+end_src

** Highlighting
#+begin_src emacs-lisp :results silent
  (use-package highlight-parentheses
    :ensure t
    :pin melpa)
  (use-package highlight-indentation
    :ensure t
    :pin melpa)
  (use-package col-highlight
    :ensure t
    :pin melpa)
  (use-package auto-highlight-symbol
    :ensure t
    :pin melpa)
  (use-package hl-sexp
    :ensure t
    :pin melpa)
  (use-package fill-column-indicator
    :ensure t
    :pin melpa)
#+end_src

** Ido
#+begin_src emacs-lisp :results silent
  (use-package ido-vertical-mode
    :ensure t
    :pin melpa)
  (use-package flx-ido
    :ensure t
    :pin melpa)
  (ido-mode 0)
  (flx-ido-mode 1)
  (setq ido-use-faces nil)
  (ido-vertical-mode 1)
#+end_src

** Modeline
#+begin_src emacs-lisp :results silent
  (use-package modeline-posn
    :ensure t
    :pin melpa)
#+end_src

** Git Commit
#+begin_src emacs-lisp :results silent
  (use-package git-commit
    :ensure t
    :pin melpa)
#+end_src

** Prettify symbols
With additional [[http://endlessparentheses.com/using-prettify-symbols-in-clojure-and-elisp-without-breaking-indentation.html][trickery]].
#+begin_src emacs-lisp :results silent
  (defun my-clojure-prettify ()
    (mapc (lambda (elt) (push elt prettify-symbols-alist))
          '(
            (">=" . (?\s
                     (Br . Bl) ?\s
                     (Bc . Bc) ?≥))
            ("<=" . (?\s
                     (Br . Bl) ?\s
                     (Bc . Bc) ?≤))
            ;; ("and" . (?\s (Br . Bl) ?\s (Br . Bl) ?∧))
            ;; ("or" . (?\s (Br . Bl) ?∨))
            ;; ("not" . (?\s (Br . Bl) ?\s (Br . Bl) ?¬))
            ("not=" . (?\s
                       (Br . Bc) ?=
                       (Br . Bc) ?=
                       (Br . Bl) ?=
                       (Br . Bc) ?=
                       (Br . Bc) ?\s
                       (Bc . Bc) ?/))
            ("->" . (?-
                     (Bc . Bl) ?-
                     (Br . Bc) ?>))
            ("->>" . (?-
                      (Bc . Bl) ?-
                      (Br . Bc) ?-
                      (Br . Bc) ?-
                      (Br . Bc) ?>
                      (Bc . Bc) ?>))
            ("#(" . (?ϝ
                     (Br . Bl) 40))
            ("fn" . (?\s (Br . Bl) ?\s
                         (Bc . Bc) ?λ)))))
  (add-hook 'clojure-mode-hook #'my-clojure-prettify)
  (defun my-js-prettify ()
    (mapc (lambda (elt) (push elt prettify-symbols-alist))
          '(
            (";" . (?▮))
            ("&&" . (?\s (Br . Bc) ?∧ (Br . Bc) ?\s))
            ("||" . (?\s (Br . Bc) ?∨ (Br . Bc) ?\s))
            ("!" . (?¬))
            ("!==" . (?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡
                       (Bc . Bc) ?/))
            ("===" . (?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡
                       (Br . Bc) ?≡))
            ("!=" . (?=
                       (Br . Bc) ?=
                       (Br . Bc) ?=
                       (Bc . Bc) ?/))
            ("==" . (?=
                       (Br . Bc) ?=
                       (Br . Bc) ?=))
            (">=" . (?\s
                     (Br . Bl) ?\s
                     (Bc . Bc) ?≥))
            ("<=" . (?\s
                     (Br . Bl) ?\s
                     (Bc . Bc) ?≤))
            ("=>" . (?=
                     (Bc . Bl) ?=
                     (Br . Bc) ?≻)))))
  (add-hook 'js-mode-hook #'my-js-prettify)
  (global-prettify-symbols-mode)
#+end_src

** Data XML customizations
*** Use a better glyph for the #xe000 separator character
#+begin_src emacs-lisp :results silent
  (add-hook 'nxml-mode-hook
            (lambda ()
              (setq buffer-display-table (make-display-table))
              (aset buffer-display-table #xe000
                    (vector (make-glyph-code ?▯ 'escape-glyph)))))
#+end_src

** Clojure customizations
*** Align let-like forms
#+begin_src emacs-lisp :results silent
  (use-package align-cljlet
    :ensure t
    :pin melpa)
  (defun my-align-let-like-forms (arg)
    (interactive "p")
    (let ((beg (region-beginning))
          (end (region-end))
          (regexp "\\s-*\\S-+\\(\\s-*\\) "))
      (cond
       ((= 1 arg) (align-cljlet))
       ((= 4 arg) (align-regexp beg end regexp))
       ;; 2015-11-04 bstiles: This case is like align-cljlet except it
       ;; doesn't test for acl-found-alignable-form before aligning
       ;; (throwing caution to the wind).
       ((= 16 arg (save-excursion
                    (acl-backward-to-code)
                    (acl-align-form)))))))
#+end_src

*** Imenu fix                                                                    :bug:
#+begin_src emacs-lisp :results silent
  (with-eval-after-load 'clojure-mode
    (defun clojure-match-next-def ()
      "Scans the buffer backwards for the next \"top-level\" definition.
  Called by `imenu--generic-function'."
      ;; we have to take into account namespace-definition forms
      ;; e.g. s/defn 2016-06-15 bstiles: Add \\sw* to capture defs that
      ;; are indented due to conditional reader forms or do blocks.
      (when (re-search-backward "^\\Sw*(\\([a-z0-9.-]+/\\)?def\\sw*" nil t)
        (save-excursion
          (let (found?
                (start (point)))
            (down-list)
            (forward-sexp)
            (while (not found?)
              (forward-sexp)
              (or (if (char-equal ?[ (char-after (point)))
                                  (backward-sexp))
                      (if (char-equal ?) (char-after (point)))
                    (backward-sexp)))
              (cl-destructuring-bind (def-beg . def-end) (bounds-of-thing-at-point 'sexp)
                (if (char-equal ?^ (char-after def-beg))
                    (progn (forward-sexp) (backward-sexp))
                  (setq found? t)
                  (set-match-data (list def-beg def-end)))))
            (goto-char start))))))
#+end_src

** Swiper search
#+begin_src emacs-lisp :results silent
  (use-package swiper
    :ensure t
    :pin melpa)
  (define-key isearch-mode-map (kbd "C-o") 'swiper-from-isearch)
#+end_src

** Time utilities
#+begin_src emacs-lisp :results silent
  (defun my-show-time ()
    (interactive)
    (let ((millis (thing-at-point 'number)))
      (if millis
          (message "%s" (format-time-string "%Y-%m-%d %T UTC"
                                            (seconds-to-time (/ millis 1000))
                                            t))
        (message "No time under point."))))
#+end_src

** Log view mode
#+begin_src emacs-lisp :results silent
  (defvar my-log-view-hidden-areas ())
  (add-to-invisibility-spec 'lv)

  (defun my-log-view-add-overlay (start end)
    (let ((overlay (make-overlay start end)))
      (setq my-log-view-hidden-areas (cons overlay my-log-view-hidden-areas))
      (overlay-put overlay 'invisible 'lv)))

  (defun my-log-view-hide-prefix ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp
              "^\\(?:..\\)?..-..-.. +..:..:..\\(?:,...\\)? +\\([^[ ]+\\|\\[[^]]+\\]\\)? +[^ ]+ +\\(\\[[^]]+\\]\\)? [^ ]+ -"
              nil t)
        (my-log-view-add-overlay (match-beginning 1) (match-end 1))
        (when (match-beginning 2)
          (my-log-view-add-overlay (match-beginning 2) (match-end 2))))))

  (defun my-log-view-show-prefix ()
    (interactive)
    (mapc (lambda (overlay) (delete-overlay overlay)) 
          my-log-view-hidden-areas)
    (setq my-log-view-hidden-areas ()))

  (define-generic-mode my-log-view-mode
    '()
    '()
    '(("^\\(\\(?:..\\)?..-..-.. +..:..:..\\(?:,...\\)? +\\(?:[^[ ]+\\|\\[[^]]+\\]\\)? +[^ ]+ +\\(?:\\[[^]]+\\]\\)? [^ ]+ -\\)"
       1 font-lock-string-face prepend)
      ("^\\(?:..\\)?..-..-.. +..:..:..\\(?:,...\\)? +\\(?:[^[ ]+\\|\\[[^]]+\\]\\)? +\\(DEBUG\\|TRACE\\) .*$"
       0 font-lock-comment-face t)
      ("^\\(?:..\\)?..-..-.. +..:..:..\\(?:,...\\)? +\\(?:[^[ ]+\\|\\[[^]]+\\]\\)? +WARN .*$"
       0 font-lock-variable-name-face t)
      ("^\\(?:..\\)?..-..-.. +..:..:..\\(?:,...\\)? +\\(?:[^[ ]+\\|\\[[^]]+\\]\\)? +\\(?:ERROR\\|FATAL\\) .*$"
       0 font-lock-warning-face t))
    '("\\.log[.0-9]*\\'")
    `(,(lambda ()
         (local-set-key (kbd "C-c l s") #'my-log-view-show-prefix)
         (local-set-key (kbd "C-c l h") #'my-log-view-hide-prefix)))
    "Minor mode for viewing logs.")
#+end_src

** Hide/show logging statements
#+begin_src emacs-lisp :results silent
  (defvar my-log-statement-hidden-areas ())
  (add-to-invisibility-spec 'ls)

  (defvar my-log-statement-regexp
    "\\(\\w*/?\\(d\\(fatal\\|error\\|warn\\|info\\|debug\\|trace\\)f?\\( +\\[?\\(:\\w+ ?\\)+]?\\)?\\)\\)")

  (defun my-log-statement-add-overlay (start end)
    (let ((overlay (make-overlay start end)))
      (setq my-log-statement-hidden-areas (cons overlay my-log-statement-hidden-areas))
      ;; (overlay-put overlay 'invisible 'ls)
      (overlay-put overlay 'face font-lock-comment-face)
      (overlay-put overlay 'display (concat "..."))))

  (defun my-log-statement-elide-collapse ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp my-log-statement-regexp nil t)
        (let (start end (more t))
          (backward-up-list)
          (when (search-backward-regexp "[^[:space:]\r\n][[:space:]\r\n]+\\=" nil t)
            (forward-char))
          (setq start (point))
          (forward-list)
          (while (search-forward-regexp
                  (concat "\\=[[:space:]\r\n]*(" my-log-statement-regexp)
                  nil t)
            (backward-up-list)
            (forward-list))
          (my-log-statement-add-overlay start (point))))))

  (defun my-log-statement-elide ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp my-log-statement-regexp nil t)
        (let (start end (more t))
          (backward-up-list)
          (setq start (point))
          (forward-list)
          (setq end (point))
          (narrow-to-region start end)
          (goto-char (point-min))
          (while (and more (search-forward-regexp "[^[:space:]]" nil t))
            (backward-char)
            (setq start (point))
            (end-of-line)
            (setq end (point))
            (my-log-statement-add-overlay start end)
            (beginning-of-line)
            (setq more (= 0 (forward-line 1))))
          (widen)))))

  (defun my-log-statement-show ()
    (interactive)
    (mapc (lambda (overlay) (delete-overlay overlay)) 
          my-log-statement-hidden-areas)
    (setq my-log-statement-hidden-areas ()))

  (with-eval-after-load 'clojure-mode
    (define-key clojure-mode-map (kbd "C-c l h") #'my-log-statement-elide)
    (define-key clojure-mode-map (kbd "C-c l H") #'my-log-statement-elide-collapse)
    (define-key clojure-mode-map (kbd "C-c l s") #'my-log-statement-show))
#+end_src

** Hide/show def contents
#+begin_src emacs-lisp :results silent
  (defvar my-def-hidden-areas ())
  (add-to-invisibility-spec 'ls)

  (defun my-def-add-overlay (start end)
    (let ((overlay (make-overlay start end)))
      (setq my-def-hidden-areas (cons overlay my-def-hidden-areas))
                                          ;    (overlay-put overlay 'invisible 'ls)
      (overlay-put overlay 'face font-lock-comment-face)
      (overlay-put overlay 'display (concat "..."))))

  (defun my-def-hide-doc-string ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp
              "^[[:space:]]*(\\(?:\\(?:[[:alnum:]]+/\\)?def[^[:space:]]*\\|comment\\)" nil t)
        (let (start end marker (more t))
          (setq marker (point))
          (backward-up-list)
          (setq start (point))
          (forward-list)
          (setq end (point))
          (narrow-to-region start end)
          (goto-char marker)
          (while (and more (search-forward-regexp "[[:space:]\r\n]+" nil t))
            (cond
             ((not (looking-at "[\"([]")) (progn
                                            (forward-sexp)
                                            (setq more t)))
             ((looking-at "[([]") (setq more nil))
             ((looking-at "\"") (progn
                                  (setq start (1+ (point)))
                                  (forward-sexp)
                                  (my-def-add-overlay start (1- (point)))
                                  (setq more nil)))))
          (widen)))))

  (defun my-def-hide-body-and-or-comment (arg)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp
              (cond
               ((equal :both arg) "^[[:space:]]*(\\(?:\\(?:[[:alnum:]]+/\\)?def[^[:space:]]*\\|comment\\)")
               ((equal :comment arg) "^[[:space:]]*(comment"))
              nil t)
        (let (start end marker (more t))
          (setq marker (point))
          (backward-up-list)
          (setq start (point))
          (forward-list)
          (setq end (point))
          (narrow-to-region start end)
          (goto-char marker)
          (if (looking-back "comment")
              (my-def-add-overlay (point) (1- end))
            (while (and more (search-forward-regexp "[[:space:]\r\n]+" nil t))
              (cond
               ((not (looking-at "[([]")) (progn
                                            (forward-sexp)
                                            (setq more t)))
               ((looking-at "(") (progn
                                   (setq start (point))
                                   (forward-sexp)
                                   (setq end (point))
                                   (goto-char start)
                                   (when (search-forward-regexp "\\[" nil t)
                                     (backward-char)
                                     (forward-sexp)
                                     (my-def-add-overlay (point) (1- end)))
                                   (goto-char end)
                                   (setq more t)))
               ((looking-at "\\[") (progn
                                     (forward-sexp)
                                     (my-def-add-overlay (point) (1- (point-max)))
                                     (setq more nil))))))
          (widen)))))

  (defun my-def-hide-body ()
    (interactive)
    (my-def-hide-body-and-or-comment :both))

  (defun my-def-hide-comment ()
    (interactive)
    (my-def-hide-body-and-or-comment :comment))

  (defun my-def-hide-def ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp
              "^[[:space:]]*(\\(?:[[:alnum:]]+/\\)?def\\(?:schema\\)?[[:space:]]+" nil t)
        (let (start end marker (more t))
          (setq marker (point))
          (backward-up-list)
          (setq start (point))
          (forward-list)
          (setq end (point))
          (narrow-to-region start end)
          (goto-char marker)
          (while (and more (search-forward-regexp "[[:space:]\r\n]*" nil t))
            (cond
             ((looking-at "\\^") (progn
                                   (forward-sexp)
                                   (setq more t)))
             (t (progn
                  (forward-sexp)
                  (my-def-add-overlay (point) (1- end))
                  (setq more nil)))))
          (widen)))))

  (defun my-def-hide-all ()
    (interactive)
    (my-def-hide-def)
    (my-def-hide-doc-string)
    (my-def-hide-body-and-or-comment :both))

  (defun my-def-show-all ()
    (interactive)
    (mapc (lambda (overlay) (delete-overlay overlay)) 
          my-def-hidden-areas)
    (setq my-def-hidden-areas ()))

  (with-eval-after-load 'clojure-mode
    (define-key clojure-mode-map (kbd "C-c d h a") #'my-def-hide-all)
    (define-key clojure-mode-map (kbd "C-c d h b") #'my-def-hide-body)
    (define-key clojure-mode-map (kbd "C-c d h c") #'my-def-hide-comment)
    (define-key clojure-mode-map (kbd "C-c d h d") #'my-def-hide-def)
    (define-key clojure-mode-map (kbd "C-c d h s") #'my-def-hide-doc-string)
    (define-key clojure-mode-map (kbd "C-c d s") #'my-def-show-all))
#+end_src

** Show page structure (based on ^L)
#+begin_src emacs-lisp :results silent
  (use-package helm-pages
    :ensure t
    :pin melpa)
#+end_src

#+begin_src emacs-lisp :results silent
  ;; 2016-03-18 bstiles: Override regexp to ignore ;;;;;;.. lines.
  (with-eval-after-load 'helm-pages
    (defun helm-pages-get-next-header ()
      "Get the next non-blank line after POINT."
      (with-helm-current-buffer
        (save-restriction
          (save-excursion
            (narrow-to-page)
            (beginning-of-line)
            (while (and (not (eobp))
                        (looking-at-p "\\(?:^\\s-*$\\|^\\s-*;+$\\|^\\s-*#+$\\|^\\s-*/+$\\)"))
              (forward-line))
            (let* ((start (progn (beginning-of-line) (point)))
                   (end (progn (end-of-line) (point))))
              (buffer-substring start end)))))))
#+end_src

** Company Mode
*** Bug fix                                                                      :bug:
https://github.com/company-mode/company-mode/issues/180

#+begin_src emacs-lisp :results silent
  (defvar-local my-company-fci-mode-on-p nil)

  (defun my-company-turn-off-fci (&rest ignore)
    (when (boundp 'fci-mode)
      (setq my-company-fci-mode-on-p fci-mode)
      (when fci-mode (fci-mode -1))))

  (defun my-company-maybe-turn-on-fci (&rest ignore)
    (when my-company-fci-mode-on-p (fci-mode 1)))

  (add-hook 'company-completion-started-hook 'my-company-turn-off-fci)
  (add-hook 'company-completion-finished-hook 'my-company-maybe-turn-on-fci)
  (add-hook 'company-completion-cancelled-hook 'my-company-maybe-turn-on-fci)
#+end_src
